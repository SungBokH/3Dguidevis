<!DOCTYPE html>
<html lang="en">

<head>
	<title>Travelling based on data</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			background-color: #cce0ff;
			color: #000;
		}

		a {
			color: #080;
		}
	</style>
</head>

<body>
	<div id="info">Simple Cloth Simulation<br />
		Verlet integration with relaxed constraints<br />
	</div>

	<script src="./js/Detector.js"></script>
	<script src="./js/THREEx.FullScreen.js"></script>
	<script src="./js/THREEx.KeyboardState.js"></script>
	<script src="./js/THREEx.WindowResize.js"></script>


	<script type="module">

		import * as THREE from '../build/three.module.js';

		import Stats from './jsm/libs/stats.module.js';
		import { GUI } from './jsm/libs/dat.gui.module.js';

		import { OrbitControls } from './jsm/controls/OrbitControls.js';

		/*
		 * Cloth Simulation using a relaxed constraints solver
		 */

		// Suggested Readings

		// Advanced Character Physics by Thomas Jakobsen Character
		// http://freespace.virgin.net/hugo.elias/models/m_cloth.htm
		// http://en.wikipedia.org/wiki/Cloth_modeling
		// http://cg.alexandra.dk/tag/spring-mass-system/
		// Real-time Cloth Animation http://www.darwin3d.com/gamedev/articles/col0599.pdf

		var params = {
			enableWind: true,
			showBall: false,
			togglePins: togglePins
		};

		var DAMPING = 0.03;
		var DRAG = 1 - DAMPING;
		var MASS = 0.1;
		var restDistance = 25;

		var xSegs = 10;
		var ySegs = 10;

		var clothFunction = plane(restDistance * xSegs, restDistance * ySegs);

		var cloth = new Cloth(xSegs, ySegs);

		var GRAVITY = 981 * 1.4;
		var gravity = new THREE.Vector3(0, - GRAVITY, 0).multiplyScalar(MASS);


		var TIMESTEP = 18 / 1000;
		var TIMESTEP_SQ = TIMESTEP * TIMESTEP;

		var pins = [];

		var windForce = new THREE.Vector3(0, 0, 0);

		var ballPosition = new THREE.Vector3(0, - 45, 0);
		var ballSize = 60; //40

		var tmpForce = new THREE.Vector3();

		var keyboard = new THREEx.KeyboardState();
		var clock = new THREE.Clock();


		function plane(width, height) {

			return function (u, v, target) {

				var x = (u - 0.5) * width;
				var y = (v + 0.5) * height;
				var z = 0;

				target.set(x, y, z);

			};

		}

		function Particle(x, y, z, mass) {

			this.position = new THREE.Vector3();
			this.previous = new THREE.Vector3();
			this.original = new THREE.Vector3();
			this.a = new THREE.Vector3(0, 0, 0); // acceleration
			this.mass = mass;
			this.invMass = 1 / mass;
			this.tmp = new THREE.Vector3();
			this.tmp2 = new THREE.Vector3();

			// init

			clothFunction(x, y, this.position); // position
			clothFunction(x, y, this.previous); // previous
			clothFunction(x, y, this.original);

		}

		// Force -> Acceleration

		Particle.prototype.addForce = function (force) {

			this.a.add(
				this.tmp2.copy(force).multiplyScalar(this.invMass)
			);

		};


		// Performs Verlet integration

		Particle.prototype.integrate = function (timesq) {

			var newPos = this.tmp.subVectors(this.position, this.previous);
			newPos.multiplyScalar(DRAG).add(this.position);
			newPos.add(this.a.multiplyScalar(timesq));

			this.tmp = this.previous;
			this.previous = this.position;
			this.position = newPos;

			this.a.set(0, 0, 0);

		};


		var diff = new THREE.Vector3();

		function satisfyConstraints(p1, p2, distance) {

			diff.subVectors(p2.position, p1.position);
			var currentDist = diff.length();
			if (currentDist === 0) return; // prevents division by 0
			var correction = diff.multiplyScalar(1 - distance / currentDist);
			var correctionHalf = correction.multiplyScalar(0.5);
			p1.position.add(correctionHalf);
			p2.position.sub(correctionHalf);

		}


		function Cloth(w, h) {

			w = w || 10;
			h = h || 10;
			this.w = w;
			this.h = h;

			var particles = [];
			var constraints = [];

			var u, v;

			// Create particles
			for (v = 0; v <= h; v++) {

				for (u = 0; u <= w; u++) {

					particles.push(
						new Particle(u / w, v / h, 0, MASS)
					);

				}

			}

			// Structural

			for (v = 0; v < h; v++) {

				for (u = 0; u < w; u++) {

					constraints.push([
						particles[index(u, v)],
						particles[index(u, v + 1)],
						restDistance
					]);

					constraints.push([
						particles[index(u, v)],
						particles[index(u + 1, v)],
						restDistance
					]);

				}

			}

			for (u = w, v = 0; v < h; v++) {

				constraints.push([
					particles[index(u, v)],
					particles[index(u, v + 1)],
					restDistance

				]);

			}

			for (v = h, u = 0; u < w; u++) {

				constraints.push([
					particles[index(u, v)],
					particles[index(u + 1, v)],
					restDistance
				]);

			}


			// While many systems use shear and bend springs,
			// the relaxed constraints model seems to be just fine
			// using structural springs.
			// Shear
			// var diagonalDist = Math.sqrt(restDistance * restDistance * 2);


			// for (v=0;v<h;v++) {
			// 	for (u=0;u<w;u++) {

			// 		constraints.push([
			// 			particles[index(u, v)],
			// 			particles[index(u+1, v+1)],
			// 			diagonalDist
			// 		]);

			// 		constraints.push([
			// 			particles[index(u+1, v)],
			// 			particles[index(u, v+1)],
			// 			diagonalDist
			// 		]);

			// 	}
			// }


			this.particles = particles;
			this.constraints = constraints;

			function index(u, v) {

				return u + v * (w + 1);

			}

			this.index = index;

		}


		/* testing cloth simulation */

		var pinsFormation = [];
		var pins = [6];

		pinsFormation.push(pins);

		pins = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
		pinsFormation.push(pins);

		pins = [0];
		pinsFormation.push(pins);

		pins = []; // cut the rope ;)
		pinsFormation.push(pins);

		pins = [0, cloth.w]; // classic 2 pins
		pinsFormation.push(pins);

		pins = pinsFormation[1];

		function togglePins() {

			pins = pinsFormation[~ ~(Math.random() * pinsFormation.length)];

		}

		var container, stats;
		var camera, scene, renderer;
		var mapCamera, mapWidth = 240, mapHeight = 160; // w/h should match div dimensions
		var clothGeometry;
		var sphere;
		var object;

		init();
		animate(0);

		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			// scene

			scene = new THREE.Scene();
			//scene.background = new THREE.Color(0xcce0ff);
			//scene.fog = new THREE.Fog(0xcce0ff, 500, 10000);

			// camera

			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.set(500, 125, 3500);
			camera.lookAt(scene.position);
			scene.add(camera);
			//map camera

			// orthographic cameras
			mapCamera = new THREE.OrthographicCamera(
				// change the zoom level by increasing/decreasing the number of inners with the same magnitude. 
				window.innerWidth / -0.25,		// Left 
				window.innerWidth / 0.25,		// Right
				window.innerHeight / 0.25,		// Top
				window.innerHeight / -0.25,	// Bottom
				-1000,            			// Near 
				100000);           			// Far 
			mapCamera.up = new THREE.Vector3(0, 0, -1);
			mapCamera.lookAt(new THREE.Vector3(0, -3000, 0));
			mapCamera.position.set(0, 0, -500);
			scene.add(mapCamera);
			//THREEx.WindowResize(renderer, mapCamera);
			// lights

			scene.add(new THREE.AmbientLight(0x666666));

			var light = new THREE.DirectionalLight(0xdfebff, 1);
			light.position.set(50, 200, 100);
			light.position.multiplyScalar(1.3);

			light.castShadow = true;

			light.shadow.mapSize.width = 1024;
			light.shadow.mapSize.height = 1024;

			var d = 500;

			light.shadow.camera.left = - d;
			light.shadow.camera.right = d;
			light.shadow.camera.top = d;
			light.shadow.camera.bottom = - d;

			light.shadow.camera.far = 1000;

			scene.add(light);

			// cloth material

			var loader = new THREE.TextureLoader();
			var clothTexture = loader.load('textures/patterns/circuit_pattern.png');
			clothTexture.anisotropy = 16;

			var clothMaterial = new THREE.MeshLambertMaterial({
				map: clothTexture,
				side: THREE.DoubleSide,
				alphaTest: 0.5
			});

			// cloth geometry

			clothGeometry = new THREE.ParametricBufferGeometry(clothFunction, cloth.w, cloth.h);

			// ground

			var groundTexture = loader.load('textures/terrain/grasslight-big.jpg');
			groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
			groundTexture.repeat.set(25, 25);
			groundTexture.anisotropy = 16;
			groundTexture.encoding = THREE.sRGBEncoding;

			var groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });

			var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(20000, 20000), groundMaterial);
			mesh.position.y = - 250;
			mesh.rotation.x = - Math.PI / 2;
			mesh.receiveShadow = true;
			scene.add(mesh);

			// adding cubes

			var cubeGeometry1 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial1 = new THREE.MeshLambertMaterial({ color: 0xff0000 });
			var cube1 = new THREE.Mesh(cubeGeometry1, cubeMaterial1);
			cube1.castShadow = true;

			// position the cube
			cube1.position.x = -0;
			cube1.position.y = -125;
			cube1.position.z = -0;

			// add the cube to the scene
			scene.add(cube1);


			var cubeGeometry2 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial2 = new THREE.MeshLambertMaterial({ color: 0xaaaa00 });
			var cube2 = new THREE.Mesh(cubeGeometry2, cubeMaterial2);
			cube2.castShadow = true;

			// position the cube
			cube2.position.x = 1000;
			cube2.position.y = -125;
			cube2.position.z = 0;

			// add the cube to the scene
			scene.add(cube2);

			var cubeGeometry3 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial3 = new THREE.MeshLambertMaterial({ color: 0xaaaa00 });
			var cube3 = new THREE.Mesh(cubeGeometry3, cubeMaterial3);
			cube3.castShadow = true;

			// position the cube
			cube3.position.x = -1000;
			cube3.position.y = -125;
			cube3.position.z = 0;

			// add the cube to the scene
			scene.add(cube3);

			var cubeGeometry4 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial4 = new THREE.MeshLambertMaterial({ color: 0xaaaa00 });
			var cube4 = new THREE.Mesh(cubeGeometry4, cubeMaterial4);
			cube4.castShadow = true;

			// position the cube
			cube4.position.x = 0;
			cube4.position.y = -125;
			cube4.position.z = 1000;

			// add the cube to the scene
			scene.add(cube4);

			var cubeGeometry5 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial5 = new THREE.MeshLambertMaterial({ color: 0xaaaa00 });
			var cube5 = new THREE.Mesh(cubeGeometry5, cubeMaterial5);
			cube5.castShadow = true;

			// position the cube
			cube5.position.x = -1000;
			cube5.position.y = -125;
			cube5.position.z = 1000;

			// add the cube to the scene
			scene.add(cube5);

			var cubeGeometry6 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial6 = new THREE.MeshLambertMaterial({ color: 0xaaaa00 });
			var cube6 = new THREE.Mesh(cubeGeometry6, cubeMaterial6);
			cube6.castShadow = true;

			// position the cube
			cube6.position.x = 1000;
			cube6.position.y = -125;
			cube6.position.z = 1000;

			// add the cube to the scene
			scene.add(cube6);


			var cubeGeometry7 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial7 = new THREE.MeshLambertMaterial({ color: 0xaaaa00 });
			var cube7 = new THREE.Mesh(cubeGeometry7, cubeMaterial7);
			cube7.castShadow = true;

			// position the cube
			cube7.position.x = 1000;
			cube7.position.y = -125;
			cube7.position.z = -1000;

			// add the cube to the scene
			scene.add(cube7);


			var cubeGeometry8 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial8 = new THREE.MeshLambertMaterial({ color: 0xaaaa00 });
			var cube8 = new THREE.Mesh(cubeGeometry8, cubeMaterial8);
			cube8.castShadow = true;

			// position the cube
			cube8.position.x = 0;
			cube8.position.y = -125;
			cube8.position.z = -1000;

			// add the cube to the scene
			scene.add(cube8);

			var cubeGeometry9 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial9 = new THREE.MeshLambertMaterial({ color: 0xaaaa00 });
			var cube9 = new THREE.Mesh(cubeGeometry8, cubeMaterial8);
			cube9.castShadow = true;

			// position the cube
			cube9.position.x = -1000;
			cube9.position.y = -125;
			cube9.position.z = -1000;

			// add the cube to the scene
			scene.add(cube9);

			var cubeGeometry10 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial10 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube10 = new THREE.Mesh(cubeGeometry10, cubeMaterial10);
			cube10.castShadow = true;

			// position the cube
			cube10.position.x = -2000;
			cube10.position.y = -125;
			cube10.position.z = 2000;

			// add the cube to the scene
			scene.add(cube10);

			var cubeGeometry11 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial11 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube11 = new THREE.Mesh(cubeGeometry11, cubeMaterial11);
			cube11.castShadow = true;

			// position the cube
			cube11.position.x = -1000;
			cube11.position.y = -125;
			cube11.position.z = 2000;

			// add the cube to the scene
			scene.add(cube11);

			var cubeGeometry12 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial12 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube12 = new THREE.Mesh(cubeGeometry12, cubeMaterial12);
			cube12.castShadow = true;

			// position the cube
			cube12.position.x = 0;
			cube12.position.y = -125;
			cube12.position.z = 2000;

			// add the cube to the scene
			scene.add(cube12);

			var cubeGeometry13 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial13 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube13 = new THREE.Mesh(cubeGeometry13, cubeMaterial13);
			cube13.castShadow = true;

			// position the cube
			cube13.position.x = 1000;
			cube13.position.y = -125;
			cube13.position.z = 2000;

			// add the cube to the scene
			scene.add(cube13);

			var cubeGeometry14 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial14 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube14 = new THREE.Mesh(cubeGeometry14, cubeMaterial14);
			cube14.castShadow = true;

			// position the cube
			cube14.position.x = 2000;
			cube14.position.y = -125;
			cube14.position.z = 2000;

			// add the cube to the scene
			scene.add(cube14);

			var cubeGeometry15 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial15 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube15 = new THREE.Mesh(cubeGeometry15, cubeMaterial15);
			cube15.castShadow = true;

			// position the cube
			cube15.position.x = 2000;
			cube15.position.y = -125;
			cube15.position.z = 1000;

			// add the cube to the scene
			scene.add(cube15);

			var cubeGeometry16 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial16 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube16 = new THREE.Mesh(cubeGeometry16, cubeMaterial16);
			cube16.castShadow = true;

			// position the cube
			cube16.position.x = 2000;
			cube16.position.y = -125;
			cube16.position.z = 0;

			// add the cube to the scene
			scene.add(cube16);

			var cubeGeometry17 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial17 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube17 = new THREE.Mesh(cubeGeometry17, cubeMaterial17);
			cube17.castShadow = true;

			// position the cube
			cube17.position.x = 2000;
			cube17.position.y = -125;
			cube17.position.z = -1000;

			// add the cube to the scene
			scene.add(cube17);


			var cubeGeometry18 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial18 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube18 = new THREE.Mesh(cubeGeometry18, cubeMaterial18);
			cube18.castShadow = true;

			// position the cube
			cube18.position.x = 2000;
			cube18.position.y = -125;
			cube18.position.z = -2000;

			// add the cube to the scene
			scene.add(cube18);

			var cubeGeometry19 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial19 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube19 = new THREE.Mesh(cubeGeometry19, cubeMaterial19);
			cube19.castShadow = true;

			// position the cube
			cube19.position.x = 1000;
			cube19.position.y = -125;
			cube19.position.z = -2000;

			// add the cube to the scene
			scene.add(cube19);

			var cubeGeometry20 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial20 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube20 = new THREE.Mesh(cubeGeometry20, cubeMaterial20);
			cube20.castShadow = true;

			// position the cube
			cube20.position.x = 0;
			cube20.position.y = -125;
			cube20.position.z = -2000;

			// add the cube to the scene
			scene.add(cube20);

			var cubeGeometry21 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial21 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube21 = new THREE.Mesh(cubeGeometry21, cubeMaterial21);
			cube21.castShadow = true;

			// position the cube
			cube21.position.x = -1000;
			cube21.position.y = -125;
			cube21.position.z = -2000;

			// add the cube to the scene
			scene.add(cube21);

			var cubeGeometry22 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial22 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube22 = new THREE.Mesh(cubeGeometry22, cubeMaterial22);
			cube22.castShadow = true;

			// position the cube
			cube22.position.x = -2000;
			cube22.position.y = -125;
			cube22.position.z = -2000;

			// add the cube to the scene
			scene.add(cube22);

			var cubeGeometry23 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial23 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube23 = new THREE.Mesh(cubeGeometry23, cubeMaterial23);
			cube23.castShadow = true;

			// position the cube
			cube23.position.x = -2000;
			cube23.position.y = -125;
			cube23.position.z = -1000;

			// add the cube to the scene
			scene.add(cube23);

			var cubeGeometry24 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial24 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube24 = new THREE.Mesh(cubeGeometry24, cubeMaterial24);
			cube24.castShadow = true;

			// position the cube
			cube24.position.x = -2000;
			cube24.position.y = -125;
			cube24.position.z = 0;

			// add the cube to the scene
			scene.add(cube24);

			var cubeGeometry25 = new THREE.BoxGeometry(500, 500, 500);
			var cubeMaterial25 = new THREE.MeshLambertMaterial({ color: 0x33aa77 });
			var cube25 = new THREE.Mesh(cubeGeometry25, cubeMaterial25);
			cube25.castShadow = true;

			// position the cube
			cube25.position.x = -2000;
			cube25.position.y = -125;
			cube25.position.z = 1000;

			// add the cube to the scene
			scene.add(cube25);

			// renderer


			//renderer = new THREE.WebGLRenderer({ antialias: true });
			if (Detector.webgl)
				renderer = new THREE.WebGLRenderer({ antialias: true });
			else
				renderer = new THREE.CanvasRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			container.appendChild(renderer.domElement);


			//THREEx.WindowResize(renderer, mapCamera);
			//THREEx.FullScreen.bindKey({ charCode: 'm'.charCodeAt(0) });


			renderer.outputEncoding = THREE.sRGBEncoding;

			renderer.shadowMap.enabled = true;
			renderer.autoClear = false;

			// controls
			var controls = new OrbitControls(camera, renderer.domElement);
			controls.maxPolarAngle = Math.PI * 0.5;
			controls.minDistance = 1;
			controls.maxDistance = 10000;
		}

		//

		//

		function animate() {

			requestAnimationFrame(animate);
			//simulate();
			render();
			//			stats.update();

		}

		function render() {

			var p = cloth.particles;
			var w = window.innerWidth, h = window.innerHeight;


			renderer.clear();
			renderer.setViewport(0, 0, w, h);
			renderer.render(scene, camera);


			renderer.clearDepth(); // important! clear the depth buffer
			renderer.setViewport(10, h - mapHeight - 10, mapWidth, mapHeight);
			renderer.render(scene, mapCamera);

		}

	</script>

</body>

</html>